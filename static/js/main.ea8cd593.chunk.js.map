{"version":3,"sources":["modules/index.js","components/TopBar.js","components/GridBox.js","components/GridBoard.js","algorithms/daijkstra.js","algorithms/aStar.js","components/Controller.js","App.js","index.js"],"names":["boardCoordinate","Array","keys","forEach","y","x","index","pointType","wall","visited","cost","shortest","Infinity","prev","initialState","startPoint","endPoint","countAxisX","countAxisY","currentSearchPoints","algorithm","visitedPoints","shortestPath","dragTarget","SET_START_POINT","SET_END_POINT","RESET_STATE","UPDATE_BOX","UPDATE_SHORTEST_PATH","UPDATE_DRAG_TARGET","updateBoxAction","payload","type","reducer","state","action","Object","newBox","point","key","boardCoordinateCopy","cloneDeep","unvisitedPoints","values","filter","el","foundEndPoint","length","searchPoints","sort","a","b","i","currentPoint","push","up","down","neighbors","undefined","lastPoint","reverse","TopBar","id","className","GridBox","props","useSelector","boxPoint","useEffect","setBoxClass","useState","boxClass","dispatch","useDispatch","updateBox","useCallback","dispatchStartPoint","setStartPointAction","dispatchEndPoint","setEndPointAction","dispatchDragTarget","updateDragTargetAction","onContextMenu","e","preventDefault","onClick","onDragEnter","stopPropagation","onDragOver","onDragEnd","onDrop","onMouseEnter","onMouseLeave","replace","draggable","GridBoard","gridList","map","gridBoard","gridRow","getGridBoard","daijkstra","orderCount","order","manhattenDistance","pointOne","pointTwo","Math","abs","aStar","openList","closedList","distanceFromStart","heuristicDistance","fValue","open","closed","includes","newCurrentPoint","splice","indexOf","StartButton","startButtonClick","trigger","restartButtonClick","disabled","ResetButton","AlgorithmDropBox","onChange","name","value","Controller","setTrigger","pathCount","setPathCount","shortestPathCount","setShortestPathCount","setElapsedTime","moveCount","setMoveCount","setShortestPath","setVisitedPoints","savedCallback","useRef","callback","current","setInterval","clearInterval","resetState","algorithmType","setAlgorithmType","target","newVisitedPointsResult","newShortestPath","App","store","createStore","rootReducer","composeWithDevTools","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.ea8cd593.chunk.js","sourcesContent":["import cloneDeep from 'lodash/fp/cloneDeep';\n\nconst countAxisX = 50;\nconst countAxisY = 20;\n\n// initializing boardCoordinate\nconst boardCoordinate = {};\n[...Array(countAxisY).keys()].forEach((y) => {\n  [...Array(countAxisX).keys()].forEach((x) => {\n    boardCoordinate[`${y}-${x}`] = {\n      index: `${y}-${x}`,\n      x: x,\n      y: y,\n      pointType: 'unvisited',\n      wall: false,\n      visited: false,\n      cost: 1,\n      shortest: Infinity, //shortest cost from startPoint\n      prev: null, //previous vertex\n    };\n  });\n});\n\nconst initialState = {\n  boardCoordinate: boardCoordinate,\n  startPoint: '5-5',\n  endPoint: '10-10',\n  countAxisX: countAxisX,\n  countAxisY: countAxisY,\n  currentSearchPoints: [],\n  algorithm: 'dijkstra',\n  visitedPoints: [],\n  shortestPath: [],\n  dragTarget: null,\n};\n\nexport const SET_START_POINT = 'gridBox/setStartPoint';\nexport const SET_END_POINT = 'gridBox/setEndPoint';\nexport const RESET_STATE = 'controllor/resetState';\nexport const UPDATE_BOX = 'controller/updateBox';\nexport const UPDATE_SHORTEST_PATH = 'controller/updateShortestPath';\nexport const UPDATE_DRAG_TARGET = 'updateDragTarget';\n\nexport function setStartPointAction({ payload }) {\n  return { type: SET_START_POINT, payload };\n}\nexport function setEndPointAction({ payload }) {\n  return { type: SET_END_POINT, payload };\n}\nexport function resetStateAction() {\n  return { type: RESET_STATE };\n}\nexport function updateBoxAction({ payload }) {\n  return { type: UPDATE_BOX, payload };\n}\nexport function updateShortestPathAction({ payload }) {\n  return { type: UPDATE_SHORTEST_PATH, payload };\n}\nexport function updateDragTargetAction({ payload }) {\n  return { type: UPDATE_DRAG_TARGET, payload };\n}\n\nconst reducer = (state = initialState, action) => {\n  switch (action.type) {\n    case SET_START_POINT: {\n      return {\n        ...state,\n        startPoint: action.payload,\n      };\n    }\n\n    case SET_END_POINT: {\n      return {\n        ...state,\n        endPoint: action.payload,\n      };\n    }\n\n    case RESET_STATE: {\n      return initialState;\n    }\n\n    case UPDATE_BOX: {\n      const payload = action.payload;\n      const keys = Object.keys(payload);\n      const newBox = {\n        ...state['boardCoordinate'][action.payload.point],\n      };\n      keys.forEach((key) => {\n        newBox[key] = payload[key];\n      });\n      return {\n        ...state,\n        boardCoordinate: {\n          ...state['boardCoordinate'],\n          [action.payload.point]: newBox,\n        },\n      };\n    }\n\n    case UPDATE_SHORTEST_PATH: {\n      switch (action.payload.algorithm) {\n        case 'Daijkstra': {\n          const visitedPoints = [];\n          const { startPoint, endPoint } = state;\n          const boardCoordinateCopy = cloneDeep(state.boardCoordinate);\n          boardCoordinateCopy[startPoint] = {\n            ...boardCoordinateCopy[startPoint],\n            shortest: 0,\n          };\n          let unvisitedPoints = Object.values(boardCoordinateCopy).filter(\n            (el) => {\n              return el.pointType === 'unvisited' && el.shortest !== Infinity;\n            }\n          );\n          let foundEndPoint = false;\n          while (unvisitedPoints.length >= 1 && foundEndPoint === false) {\n            const searchPoints = unvisitedPoints.sort(function (a, b) {\n              if (a.shortest >= b.shortest) {\n                return 1;\n              } else {\n                return -1;\n              }\n            });\n            for (let i = 0; i < searchPoints.length; i++) {\n              const currentPoint = searchPoints[i];\n              if (currentPoint.index === endPoint) {\n                foundEndPoint = true;\n                break;\n              } else {\n                boardCoordinateCopy[currentPoint.index].pointType = 'visited';\n                visitedPoints.push(currentPoint);\n                const x = currentPoint.x;\n                const y = currentPoint.y;\n                const up = `${y + 1}-${x}`;\n                const down = `${y - 1}-${x}`;\n                const left = `${y}-${x - 1}`;\n                const right = `${y}-${x + 1}`;\n                const neighbors = [left, up, down, right].filter(\n                  (point) =>\n                    boardCoordinateCopy[point] !== undefined &&\n                    boardCoordinateCopy[point].pointType === 'unvisited'\n                );\n                if (neighbors.length > 0) {\n                  neighbors.forEach((point) => {\n                    if (\n                      boardCoordinateCopy[point].shortest >\n                      boardCoordinateCopy[point].cost + currentPoint.shortest\n                    ) {\n                      boardCoordinateCopy[point].shortest =\n                        currentPoint.shortest;\n                      boardCoordinateCopy[point].prev = currentPoint.index;\n                    }\n                  });\n                }\n              }\n            }\n            unvisitedPoints = Object.values(boardCoordinateCopy).filter(\n              (el) => {\n                return el.pointType === 'unvisited' && el.shortest !== Infinity;\n              }\n            );\n          }\n\n          const shortestPath = [];\n          let lastPoint = endPoint;\n          while (lastPoint !== null) {\n            if (boardCoordinateCopy[lastPoint] !== undefined) {\n              lastPoint = boardCoordinateCopy[lastPoint].prev;\n              if (lastPoint !== null) {\n                shortestPath.push(lastPoint);\n                boardCoordinateCopy[lastPoint].pointType = 'path';\n              }\n            } else {\n              lastPoint = null;\n            }\n          }\n          shortestPath.reverse();\n          return {\n            ...state,\n            visitedPoints: visitedPoints,\n            shortestPath: shortestPath,\n          };\n        }\n        default:\n          return state;\n      }\n    }\n\n    case UPDATE_DRAG_TARGET: {\n      const payload = action.payload;\n      return {\n        ...state,\n        dragTarget: payload,\n      };\n    }\n    default:\n      return state;\n  }\n};\n\nexport default reducer;\n","import React from 'react';\n\nconst TopBar = () => {\n  const mainDiv = (\n    <article id=\"topbar\">\n      <section className=\"title\">Pathfinding Visualizer</section>\n    </article>\n  );\n  return mainDiv;\n};\n\nexport default TopBar;\n","import React, { useState, useEffect, useCallback } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport {\n  updateBoxAction,\n  setStartPointAction,\n  setEndPointAction,\n  updateDragTargetAction,\n} from '../modules';\n\nconst GridBox = (props) => {\n  const { x, y, pointType, visited, wall } = props;\n  const { startPoint, endPoint, dragTarget } = useSelector(\n    ({ startPoint, endPoint, dragTarget }) => ({\n      startPoint,\n      endPoint,\n      dragTarget,\n    })\n  );\n  const boxPoint = `${y}-${x}`;\n  useEffect(() => {\n    if (pointType === 'path') {\n      setBoxClass('box path');\n    } else if (pointType === 'unvisited') {\n      setBoxClass('box');\n    } else if (pointType === 'visited') {\n      setBoxClass('box visited');\n    } else if (pointType === 'wall') {\n      setBoxClass('box wall');\n    }\n\n    if (boxPoint === startPoint) {\n      setBoxClass('box start-point');\n    } else if (boxPoint === endPoint) {\n      setBoxClass('box end-point');\n    }\n  }, [startPoint, endPoint, boxPoint, pointType, wall, visited]);\n  const [boxClass, setBoxClass] = useState('box');\n\n  const { boardCoordinate } = useSelector(({ boardCoordinate }) => ({\n    boardCoordinate: boardCoordinate,\n  }));\n\n  const dispatch = useDispatch();\n\n  const updateBox = useCallback(\n    (payload) =>\n      dispatch(\n        updateBoxAction({\n          payload: payload,\n        })\n      ),\n    [dispatch]\n  );\n\n  const dispatchStartPoint = useCallback(\n    (payload) => {\n      dispatch(\n        setStartPointAction({\n          payload: payload,\n        })\n      );\n    },\n    [dispatch]\n  );\n\n  const dispatchEndPoint = useCallback(\n    (payload) => {\n      dispatch(\n        setEndPointAction({\n          payload: payload,\n        })\n      );\n    },\n    [dispatch]\n  );\n\n  const mouseEnter = () => {\n    setBoxClass(boxClass + ' hover');\n  };\n  const mouseLeave = () => {\n    setBoxClass(boxClass.replace(' hover', ''));\n  };\n  const rightMouseClick = (e) => {\n    e.preventDefault();\n    dispatchEndPoint(boxPoint);\n    // setBoxClass(\"box start-point\");\n  };\n\n  const onClick = (e) => {\n    e.preventDefault();\n    updateBox({\n      point: boxPoint,\n      pointType:\n        boardCoordinate[boxPoint]['pointType'] === 'wall'\n          ? 'unvisited'\n          : 'wall',\n    });\n  };\n  const dispatchDragTarget = useCallback(\n    (payload) => {\n      dispatch(\n        updateDragTargetAction({\n          payload: payload,\n        })\n      );\n    },\n    [dispatch]\n  );\n\n  const onDragEnter = (e) => {\n    e.stopPropagation();\n    e.preventDefault();\n    if (boxPoint === startPoint) {\n      dispatchDragTarget('startPoint');\n    } else if (boxPoint === endPoint) {\n      dispatchDragTarget('endPoint');\n    } else if (dragTarget === null) {\n      updateBox({\n        point: boxPoint,\n        pointType:\n          boardCoordinate[boxPoint]['pointType'] === 'wall'\n            ? 'unvisited'\n            : 'wall',\n      });\n    }\n  };\n\n  const onDragOver = (e) => {\n    // The default action for dragOver is \"Reset the current drag operation to none\".\n    e.preventDefault();\n  };\n\n  const onDragEnd = (e) => {\n    e.preventDefault();\n    dispatchDragTarget(null);\n  };\n\n  const onDrop = (e) => {\n    if (dragTarget === 'startPoint') {\n      dispatchStartPoint(boxPoint);\n    } else if (dragTarget === 'endPoint') {\n      dispatchEndPoint(boxPoint);\n    }\n  };\n  return (\n    <div\n      id={`column ${boxPoint}`}\n      className={boxClass}\n      onContextMenu={rightMouseClick}\n      onClick={onClick}\n      onDragEnter={onDragEnter}\n      onDragOver={onDragOver}\n      onDragEnd={onDragEnd}\n      onDrop={onDrop}\n      onMouseEnter={mouseEnter}\n      onMouseLeave={mouseLeave}\n      draggable={true}\n    ></div>\n  );\n};\n\nexport default GridBox;\n","import React from 'react';\nimport GridBox from './GridBox';\nimport { useSelector } from 'react-redux';\n\nconst GridBoard = () => {\n  const { countAxisY } = useSelector(({ countAxisY }) => ({\n    countAxisY,\n  }));\n\n  const { boardCoordinate } = useSelector(({ boardCoordinate }) => ({\n    boardCoordinate: boardCoordinate,\n  }));\n\n  const gridList = Object.keys(boardCoordinate).map((point) => {\n    const { x, y, pointType, visited, wall, cost } = boardCoordinate[point];\n    const key = `${y}-${x}`;\n    const gridBox = (\n      <GridBox\n        x={x}\n        y={y}\n        pointType={pointType}\n        visited={visited}\n        wall={wall}\n        cost={cost}\n        key={key}\n      ></GridBox>\n    );\n    return gridBox;\n  });\n\n  const getGridBoard = () => {\n    const gridBoard = [];\n    [...Array(countAxisY).keys()].forEach((y) => {\n      const gridRow = gridList.filter((el) => el.props.y === y);\n      gridBoard.push(\n        <div className=\"row\" key={`row-${y}`}>\n          {gridRow}\n        </div>\n      );\n    });\n    return gridBoard;\n  };\n\n  return <section className=\"grid-board\">{getGridBoard()}</section>;\n};\n\nexport default GridBoard;\n","import { cloneDeep } from 'lodash';\n\nconst daijkstra = (boardCoordinate, startPoint, endPoint) => {\n  const visitedPoints = [];\n  const boardCoordinateCopy = cloneDeep(boardCoordinate);\n  let orderCount = 0;\n  boardCoordinateCopy[startPoint] = {\n    ...boardCoordinateCopy[startPoint],\n    shortest: 0,\n    order: orderCount,\n  };\n  orderCount = +1;\n  let unvisitedPoints = Object.values(boardCoordinateCopy).filter((el) => {\n    return el.pointType === 'unvisited' && el.shortest !== Infinity;\n  });\n  let foundEndPoint = false;\n  while (unvisitedPoints.length >= 1 && foundEndPoint === false) {\n    const searchPoints = unvisitedPoints.sort(function (a, b) {\n      if (a.shortest >= b.shortest) {\n        return 1;\n      } else {\n        return -1;\n      }\n    });\n    for (let i = 0; i < searchPoints.length; i++) {\n      const currentPoint = searchPoints[i];\n      if (currentPoint.index === endPoint) {\n        foundEndPoint = true;\n        break;\n      } else {\n        boardCoordinateCopy[currentPoint.index].pointType = 'visited';\n        boardCoordinateCopy[currentPoint.index].order = orderCount;\n        orderCount += 1;\n        visitedPoints.push(currentPoint);\n        const x = currentPoint.x;\n        const y = currentPoint.y;\n        const up = `${y + 1}-${x}`;\n        const down = `${y - 1}-${x}`;\n        const left = `${y}-${x - 1}`;\n        const right = `${y}-${x + 1}`;\n        const neighbors = [left, up, down, right].filter(\n          (point) =>\n            boardCoordinateCopy[point] !== undefined &&\n            boardCoordinateCopy[point].pointType === 'unvisited'\n        );\n        if (neighbors.length > 0) {\n          neighbors.forEach((point) => {\n            if (\n              boardCoordinateCopy[point].shortest >\n              boardCoordinateCopy[point].cost + currentPoint.shortest\n            ) {\n              boardCoordinateCopy[point].shortest = currentPoint.shortest;\n              boardCoordinateCopy[point].prev = currentPoint.index;\n            }\n          });\n        }\n      }\n    }\n    unvisitedPoints = Object.values(boardCoordinateCopy).filter((el) => {\n      return el.pointType === 'unvisited' && el.shortest !== Infinity;\n    });\n  }\n\n  const shortestPath = [];\n  let lastPoint = endPoint;\n  while (lastPoint !== null) {\n    if (boardCoordinateCopy[lastPoint] !== undefined) {\n      lastPoint = boardCoordinateCopy[lastPoint].prev;\n      if (lastPoint !== null) {\n        shortestPath.push(lastPoint);\n        boardCoordinateCopy[lastPoint].pointType = 'path';\n        // boardCoordinateCopy[lastPoint].order = orderCount;\n        orderCount += 1;\n      }\n    } else {\n      lastPoint = null;\n    }\n  }\n  shortestPath.reverse();\n  return {\n    visitedPoints: visitedPoints,\n    shortestPath: shortestPath,\n  };\n};\n\nexport default daijkstra;\n","import { cloneDeep } from 'lodash';\n\nconst manhattenDistance = (pointOne, pointTwo, boardCoordinateCopy) => {\n  let dx = Math.abs(\n    boardCoordinateCopy[pointOne].x - boardCoordinateCopy[pointTwo].x\n  );\n  let dy = Math.abs(\n    boardCoordinateCopy[pointOne].y - boardCoordinateCopy[pointTwo].y\n  );\n  return dx + dy;\n};\n\nconst euclideanDistance = (pointOne, pointTwo, boardCoordinateCopy) => {\n  let dx = boardCoordinateCopy[pointOne].x - boardCoordinateCopy[pointTwo].x;\n  let dy = boardCoordinateCopy[pointOne].y - boardCoordinateCopy[pointTwo].y;\n  return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n};\n\nconst aStar = (boardCoordinate, startPoint, endPoint) => {\n  const boardCoordinateCopy = cloneDeep(boardCoordinate);\n  const visitedPoints = [];\n  const shortestPath = [];\n  const openList = [];\n  const closedList = [];\n  boardCoordinateCopy[startPoint] = {\n    ...boardCoordinateCopy[startPoint],\n    distanceFromStart: 0,\n    heuristicDistance: 0,\n    fValue: null,\n    open: false,\n    closed: false,\n    prev: null,\n  };\n  let currentPoint = boardCoordinateCopy[startPoint];\n  while (currentPoint.index !== endPoint) {\n    const neighbors = ((currentPoint) => {\n      const x = currentPoint.x;\n      const y = currentPoint.y;\n      const up = `${y + 1}-${x}`;\n      const down = `${y - 1}-${x}`;\n      const left = `${y}-${x - 1}`;\n      const right = `${y}-${x + 1}`;\n      return [left, up, down, right].filter(\n        (point) =>\n          boardCoordinateCopy[point] !== undefined &&\n          boardCoordinateCopy[point].pointType === 'unvisited'\n      );\n    })(currentPoint);\n    neighbors.forEach((point) => {\n      if (!openList.includes(point) && !closedList.includes(point)) {\n        openList.push(point);\n        const distanceFromStart =\n          Math.abs(\n            boardCoordinateCopy[startPoint].x - boardCoordinateCopy[point].x\n          ) +\n          Math.abs(\n            boardCoordinateCopy[startPoint].y - boardCoordinateCopy[point].y\n          );\n        // http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S7\n        const heuristicDistance = manhattenDistance(\n          endPoint,\n          point,\n          boardCoordinateCopy\n        );\n        const fValue = distanceFromStart + heuristicDistance;\n\n        if (\n          fValue < boardCoordinateCopy[point].fValue ||\n          boardCoordinateCopy[point].fValue === undefined\n        ) {\n          boardCoordinateCopy[point].distanceFromStart = distanceFromStart;\n          boardCoordinateCopy[point].heuristicDistance = heuristicDistance;\n          boardCoordinateCopy[point].fValue = fValue;\n          boardCoordinateCopy[point].prev = currentPoint.index;\n        }\n      }\n    });\n    closedList.push(currentPoint.index);\n    const newCurrentPoint = ((openList) => {\n      const openListPoints = openList.map((point) => {\n        return boardCoordinateCopy[point];\n      });\n      const sortList = openListPoints.sort((a, b) => {\n        if (a.fValue <= b.fValue) {\n          return -1;\n        } else {\n          return 1;\n        }\n      });\n      return sortList[0];\n    })(openList);\n    openList.splice(openList.indexOf(newCurrentPoint.index), 1);\n    visitedPoints.push(currentPoint);\n    currentPoint = newCurrentPoint;\n  }\n  let prev = boardCoordinateCopy[endPoint].prev;\n  while (prev != null) {\n    shortestPath.push(prev);\n    prev = boardCoordinateCopy[prev].prev;\n  }\n  shortestPath.reverse();\n  return {\n    visitedPoints: visitedPoints,\n    shortestPath: shortestPath,\n  };\n};\nexport default aStar;\n","import React, { useState, useCallback, useEffect, useRef } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport daijkstra from '../algorithms/daijkstra';\nimport aStar from '../algorithms/aStar';\nimport { updateBoxAction, resetStateAction } from '../modules';\n\nconst StartButton = ({ startButtonClick, restartButtonClick, trigger }) => {\n  return (\n    <div className=\"button-wrap\">\n      <button\n        className=\"button start\"\n        onClick={startButtonClick}\n        disabled={trigger}\n      >\n        START\n      </button>\n    </div>\n  );\n};\n\nconst ResetButton = ({ onClick }) => {\n  return (\n    <div className=\"button-wrap\">\n      <button className=\"button reset\" onClick={onClick}>\n        RESET\n      </button>\n    </div>\n  );\n};\n\nconst AlgorithmDropBox = ({ onChange }) => {\n  return (\n    <div className=\"button-wrap\">\n      <form>\n        {/* <label htmlFor=\"algorithm\">algorithm:</label> */}\n        <select\n          className=\"select-container\"\n          name=\"algorithm\"\n          onChange={onChange}\n        >\n          <option value=\"A-star\">A-star</option>\n          <option value=\"Daijkstra\">Daijkstra</option>\n        </select>\n      </form>\n    </div>\n  );\n};\n\nconst Controller = () => {\n  const { boardCoordinate, startPoint, endPoint } = useSelector(\n    ({ boardCoordinate, startPoint, endPoint }) => ({\n      boardCoordinate: boardCoordinate,\n      startPoint: startPoint,\n      endPoint: endPoint,\n    })\n  );\n  const dispatch = useDispatch();\n  const updateBox = useCallback(\n    (payload) =>\n      dispatch(\n        updateBoxAction({\n          payload: payload,\n        })\n      ),\n    [dispatch]\n  );\n\n  const [trigger, setTrigger] = useState(false);\n  const [pathCount, setPathCount] = useState(0);\n  const [shortestPathCount, setShortestPathCount] = useState(0);\n  const [elapsedTime, setElapsedTime] = useState('00:00:00');\n  const [moveCount, setMoveCount] = useState(0);\n\n  const [shortestPath, setShortestPath] = useState([]);\n  const [visitedPoints, setVisitedPoints] = useState([]);\n\n  const savedCallback = useRef();\n  function callback() {\n    if (visitedPoints[pathCount] !== undefined) {\n      updateBox({\n        point: visitedPoints[pathCount].index,\n        pointType: 'visited',\n      });\n      setMoveCount(moveCount + 1);\n      setPathCount(pathCount + 1);\n    } else {\n      updateBox({\n        point: shortestPath[shortestPathCount],\n        pointType: 'path',\n      });\n      setShortestPathCount(shortestPathCount + 1);\n    }\n  }\n\n  useEffect(() => {\n    savedCallback.current = callback;\n  });\n\n  useEffect(() => {\n    function tick() {\n      savedCallback.current();\n    }\n    if (trigger) {\n      let id = setInterval(tick, 3);\n      return () => {\n        clearInterval(id);\n      };\n    }\n  }, [trigger]);\n\n  const startButtonClick = () => {\n    const {\n      visitedPoints: newVisitedPointsResult,\n      shortestPath: newShortestPath,\n    } = ((algorithmType) => {\n      if (algorithmType === 'Daijkstra') {\n        return daijkstra(boardCoordinate, startPoint, endPoint);\n      } else if (algorithmType === 'A-star') {\n        return aStar(boardCoordinate, startPoint, endPoint);\n      }\n    })(algorithmType);\n    setVisitedPoints(newVisitedPointsResult);\n    setShortestPath(newShortestPath);\n    setTrigger(true);\n  };\n\n  const restartButtonClick = () => {\n    setTrigger(false);\n  };\n\n  const resetState = useCallback(() => {\n    dispatch(resetStateAction());\n  }, [dispatch]);\n\n  const resetButtonClick = () => {\n    setTrigger(false);\n    setPathCount(0);\n    setShortestPathCount(0);\n    setMoveCount(0);\n    setElapsedTime('00:00:00');\n    resetState();\n  };\n  const [algorithmType, setAlgorithmType] = useState('A-star');\n  const algorithmTypeChange = (e) => {\n    setAlgorithmType(e.target.value);\n  };\n\n  return (\n    <section id=\"controller\">\n      <div className=\"right\">\n        <AlgorithmDropBox onChange={algorithmTypeChange}></AlgorithmDropBox>\n        <StartButton\n          startButtonClick={startButtonClick}\n          restartButtonClick={restartButtonClick}\n          trigger={trigger}\n        />\n        <ResetButton onClick={resetButtonClick} />\n        <div className=\"counter\">\n          {/* <div className=\"counter-box\">\n                        <p className=\"elapsed-time\">{elapsedTime}</p>\n                    </div> */}\n          <div className=\"counter-box\">\n            <p className=\"move-counter\">{moveCount}</p>\n          </div>\n        </div>\n      </div>\n    </section>\n  );\n};\n\nexport default Controller;\n","import React from 'react';\nimport TopBar from './components/TopBar';\nimport GridBoard from './components/GridBoard';\nimport Controller from './components/Controller';\n\nconst App = () => {\n  return (\n    <div>\n      <header>\n        <TopBar />\n      </header>\n      <main>\n        <article>\n          <Controller />\n          <GridBoard />\n        </article>\n      </main>\n    </div>\n  );\n};\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { createStore } from 'redux';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport { Provider } from 'react-redux';\nimport rootReducer from './modules';\nimport App from './App';\nimport './scss/App.scss';\n\nconst store = createStore(rootReducer, composeWithDevTools());\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}